#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import math
import time
from time import sleep
import threading
import serial
from math import sqrt

from mbientlab.metawear import (
    MetaWear,
    libmetawear,
    parse_value,
    AccBmi160Odr,
    AccBoschRange,
    GyroBoschRange,
    GyroBoschOdr
)
from mbientlab.metawear.cbindings import FnVoid_VoidP_DataP
from mbientlab.warble import WarbleException

# ==========================
#  Parámetros de operación
# ==========================
SENSOR_MAC = "C3:A9:C3:20:4A:9B"   # <-- cambia si hace falta
SERIAL_PORT = "/dev/ttyACM0"
BAUD = 115200

DT_MS    = 10       # periodo del filtro en ms (modificable)
ALPHA    = 0.98     # alpha fijo del complementario (modificable)
PRINT_MS = 500      # intervalo de impresión en consola (ms)

SEND_UART = True    # enviamos por UART al Arduino (cada DT_MS)

# ==========================
#  Serial (UART) a Arduino
# ==========================
try:
    arduino_serial = serial.Serial(SERIAL_PORT, BAUD, timeout=1)
    print(f"UART OK en {SERIAL_PORT} @{BAUD}")
except Exception as e:
    print(f"[UART] Error abriendo puerto: {e}")
    arduino_serial = None

def uart_send(line: str):
    if SEND_UART and arduino_serial:
        try:
            arduino_serial.write((line + "\n").encode())
        except Exception as e:
            print("[UART] Error TX:", e)

# ==========================================
#  Buffers compartidos (acc/gyro remapeados)
# ==========================================
latest_acc  = {"x": 0.0, "y": 0.0, "z": 0.0}   # g
latest_gyro = {"x": 0.0, "y": 0.0, "z": 0.0}   # dps
_data_lock = threading.Lock()
_have_first_samples = threading.Event()

# ==========================
#  Filtro complementario (método clásico)
# ==========================
class ComplementaryFilterClassic:
    """
    Convención de ejes (silla/persona):
      X: hacia el frente
      Y: hacia la izquierda
      Z: hacia arriba

    Definición de ángulos:
      - roll  : rotación alrededor de X (tumbarse a los lados)
      - pitch : rotación alrededor de Y (cabeceo)

    Método clásico (solo acelerómetro):
      roll_acc  = atan(  ay / sqrt(ax^2 + az^2) )
      pitch_acc = atan( -ax / sqrt(ay^2 + az^2) )
    """
    RAD2DEG = 180.0 / math.pi

    def __init__(self, alpha=0.98):
        self.alpha = float(alpha)
        self.roll  = 0.0  # rad
        self.pitch = 0.0  # rad
        self.init  = False
        # Bias simple de gyro (promedio inicial)
        self._bx = 0.0
        self._by = 0.0
        self._n_bias = 0

    def _acc_angles_classic(self, ax, ay, az):
        eps = 1e-9
        roll_acc  = math.atan(  ay / max(eps, sqrt(ax*ax + az*az)) )
        pitch_acc = math.atan( -ax / max(eps, sqrt(ay*ay + az*az)) )
        return roll_acc, pitch_acc

    def update(self, ax_g, ay_g, az_g, gx_dps, gy_dps, dt_s):
        # gyro: dps -> rad/s
        gx = math.radians(gx_dps)
        gy = math.radians(gy_dps)

        # Ángulos por acelerómetro (clásico)
        roll_acc, pitch_acc = self._acc_angles_classic(ax_g, ay_g, az_g)

        if not self.init:
            self.roll, self.pitch = roll_acc, pitch_acc
            self.init = True
            # arranque de bias
            self._n_bias = 1
            self._bx = gx
            self._by = gy
        elif self._n_bias < 50:  # ~0.5 s si dt=10 ms
            self._n_bias += 1
            self._bx += (gx - self._bx)/self._n_bias
            self._by += (gy - self._by)/self._n_bias

        # Integración del gyro (restando bias)
        roll_gyro  = self.roll  + (gx - self._bx)*dt_s
        pitch_gyro = self.pitch + (gy - self._by)*dt_s

        a = self.alpha
        self.roll  = a*roll_gyro  + (1.0-a)*roll_acc
        self.pitch = a*pitch_gyro + (1.0-a)*pitch_acc

        return (-self.pitch*self.RAD2DEG, self.roll*self.RAD2DEG)  # deg

# ==========================
#  Callbacks BLE (MetaWear)
# ==========================
class State:
    def __init__(self, device):
        self.device = device
        self.accCallback  = FnVoid_VoidP_DataP(self.acc_handler)
        self.gyroCallback = FnVoid_VoidP_DataP(self.gyro_handler)

    def acc_handler(self, ctx, data):
        try:
            acc = parse_value(data)  # g
            with _data_lock:
                # Remapeo: X=frente, Y=izq, Z=arriba
                latest_acc["x"] = -acc.z
                latest_acc["y"] = +acc.y
                latest_acc["z"] = -acc.x
            _have_first_samples.set()
        except Exception as e:
            print("[ACC] Error:", e)

    def gyro_handler(self, ctx, data):
        try:
            gyro = parse_value(data)  # dps
            with _data_lock:
                latest_gyro["x"] =  gyro.z
                latest_gyro["y"] = -gyro.y
                latest_gyro["z"] =  gyro.x
            _have_first_samples.set()
        except Exception as e:
            print("[GYRO] Error:", e)

# ==========================
#  BLE helpers
# ==========================
def connect_con_intentos(mac, tries=4, base_delay=1.2):
    last = None
    for i in range(1, tries+1):
        dev = MetaWear(mac)
        try:
            print(f"[BLE] Conectando a {mac} (intento {i}/{tries})...")
            dev.connect()
            time.sleep(0.8)
            print("[BLE] Conectado.")
            return dev
        except WarbleException as e:
            last = e
            print("[BLE] Falló, reintentando...")
            try: libmetawear.mbl_mw_debug_disconnect(dev.board)
            except: pass
            try: dev.disconnect()
            except: pass
            time.sleep(base_delay*i)
    raise last or RuntimeError("No se pudo conectar BLE")

# ==========================
#  Loop a dt fijo (envío UART cada DT)
# ==========================
def run_filter_fixed_dt_and_uart():
    filt = ComplementaryFilterClassic(alpha=ALPHA)

    dt_s = DT_MS / 1000.0
    next_t = time.perf_counter()
    last_print = time.perf_counter()

    print(f"\n[FILTRO clásico] dt={DT_MS} ms | alpha={ALPHA:.3f}")
    print("Enviando por UART: ANGLES_RPI,pitch_deg=...,roll_deg=...,alpha=...,dt_ms=...\n")

    while True:
        # Tomar última muestra disponible
        with _data_lock:
            ax = latest_acc["x"]; ay = latest_acc["y"]; az = latest_acc["z"]
            gx = latest_gyro["x"]; gy = latest_gyro["y"]

        pitch_deg, roll_deg = filt.update(ax, ay, az, gx, gy, dt_s)

        # Envío UART cada DT
        uart_send(
            "ANGLES_RPI,pitch_deg={:.2f},roll_deg={:.2f},alpha={:.3f},dt_ms={:.1f}"
            .format(pitch_deg, roll_deg, ALPHA, DT_MS)
        )

        # Print cada PRINT_MS
        now = time.perf_counter()
        if (now - last_print) >= (PRINT_MS/1000.0):
            last_print = now
            print("pitch={:+7.2f}°, roll={:+7.2f}°  |  alpha={:.2f}, dt={} ms"
                  .format(pitch_deg, roll_deg, ALPHA, DT_MS))

        # Mantener dt fijo
        next_t += dt_s
        sleep_time = next_t - time.perf_counter()
        if sleep_time > 0:
            time.sleep(sleep_time)
        else:
            next_t = time.perf_counter()

# ==========================
#  MAIN
# ==========================
def main():
    # Conectar BLE + configurar sensores
    device = connect_con_intentos(SENSOR_MAC, tries=4)
    state = State(device)

    print("[BLE] Configurando...")
    libmetawear.mbl_mw_settings_set_connection_parameters(device.board, 7.5, 7.5, 0, 6000)
    sleep(1.0)

    # Acelerómetro 50 Hz, ±4g
    libmetawear.mbl_mw_acc_bmi160_set_odr(device.board, AccBmi160Odr._50Hz)
    libmetawear.mbl_mw_acc_bosch_set_range(device.board, AccBoschRange._4G)
    libmetawear.mbl_mw_acc_write_acceleration_config(device.board)

    # Giroscopio 50 Hz, ±1000 dps
    libmetawear.mbl_mw_gyro_bmi160_set_range(device.board, GyroBoschRange._1000dps)
    libmetawear.mbl_mw_gyro_bmi160_set_odr(device.board, GyroBoschOdr._50Hz)
    libmetawear.mbl_mw_gyro_bmi160_write_config(device.board)

    # Señales y suscripciones
    acc_signal  = libmetawear.mbl_mw_acc_get_acceleration_data_signal(device.board)
    gyro_signal = libmetawear.mbl_mw_gyro_bmi160_get_rotation_data_signal(device.board)

    libmetawear.mbl_mw_datasignal_subscribe(acc_signal, None, state.accCallback)
    libmetawear.mbl_mw_datasignal_subscribe(gyro_signal, None, state.gyroCallback)

    # Start
    libmetawear.mbl_mw_acc_enable_acceleration_sampling(device.board)
    libmetawear.mbl_mw_acc_start(device.board)
    libmetawear.mbl_mw_gyro_bmi160_enable_rotation_sampling(device.board)
    libmetawear.mbl_mw_gyro_bmi160_start(device.board)

    print("[RUN] Esperando primeras muestras...")
    _have_first_samples.wait(timeout=2.0)
    print("[RUN] Filtro clásico + UART. Ctrl+C para salir.")

    try:
        run_filter_fixed_dt_and_uart()
    except KeyboardInterrupt:
        print("\n[STOP] Deteniendo y cerrando...")
    finally:
        # Parar sensores y limpiar
        libmetawear.mbl_mw_acc_stop(device.board)
        libmetawear.mbl_mw_acc_disable_acceleration_sampling(device.board)
        libmetawear.mbl_mw_gyro_bmi160_stop(device.board)
        libmetawear.mbl_mw_gyro_bmi160_disable_rotation_sampling(device.board)
        libmetawear.mbl_mw_datasignal_unsubscribe(acc_signal)
        libmetawear.mbl_mw_datasignal_unsubscribe(gyro_signal)
        device.disconnect()

        if arduino_serial:
            try:
                arduino_serial.close()
            except: pass

        print("[OK] Desconectado correctamente.")

if __name__ == "__main__":
    main()
